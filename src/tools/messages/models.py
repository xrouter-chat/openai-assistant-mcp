"""Pydantic models for OpenAI Message API.

This module provides type-safe models for interacting with the OpenAI Message API,
including models for message content, annotations, and message-specific operations.
"""

from typing import List, Literal, Optional, Union

from pydantic import BaseModel, Field

from ..models import CodeInterpreterTool, FileSearchTool, Metadata


class ImageFileContent(BaseModel):
    """Model for image file content."""

    file_id: str = Field(
        description="The File ID of the image in the message content. "
        "Set purpose='vision' when uploading the File"
    )
    detail: Optional[Literal["auto", "low", "high"]] = Field(
        default="auto",
        description="Specifies the detail level of the image. low uses fewer tokens",
    )


class MessageImageFile(BaseModel):
    """Model for image file message content."""

    type: Literal["image_file"] = Field(
        description="The type of content part. Always image_file"
    )
    image_file: ImageFileContent


class ImageUrlContent(BaseModel):
    """Model for image URL content."""

    url: str = Field(
        description="The external URL of the image, must be supported types: "
        "jpeg, jpg, png, gif, webp"
    )
    detail: Optional[Literal["auto", "low", "high"]] = Field(
        default="auto",
        description="Specifies the detail level of the image. low uses fewer tokens",
    )


class MessageImageUrl(BaseModel):
    """Model for image URL message content."""

    type: Literal["image_url"] = Field(
        description="The type of content part. Always image_url"
    )
    image_url: ImageUrlContent


class FileCitationDetail(BaseModel):
    """Model for file citation details."""

    file_id: str = Field(description="The ID of the specific File the citation is from")


class FileCitationAnnotation(BaseModel):
    """Model for file citation annotations."""

    type: Literal["file_citation"] = Field(
        description="The type of annotation. Always file_citation"
    )
    text: str = Field(
        description="The text in the message content that needs to be replaced"
    )
    file_citation: FileCitationDetail
    start_index: int = Field(description="Start index of the annotation")
    end_index: int = Field(description="End index of the annotation")


class FilePathDetail(BaseModel):
    """Model for file path details."""

    file_id: str = Field(description="The ID of the file that was generated")


class FilePathAnnotation(BaseModel):
    """Model for file path annotations."""

    type: Literal["file_path"] = Field(
        description="The type of annotation. Always file_path"
    )
    text: str = Field(
        description="The text in the message content that needs to be replaced"
    )
    file_path: FilePathDetail
    start_index: int = Field(description="Start index of the annotation")
    end_index: int = Field(description="End index of the annotation")


class TextContent(BaseModel):
    """Model for text content."""

    value: str = Field(description="The data that makes up the text")
    annotations: List[Union[FileCitationAnnotation, FilePathAnnotation]] = Field(
        default_factory=list,
        description="Annotations providing additional context or references",
    )


class MessageText(BaseModel):
    """Model for text message content."""

    type: Literal["text"] = Field(description="The type of content part. Always text")
    text: TextContent


class RefusalContent(BaseModel):
    """Model for refusal content."""

    refusal: str = Field(description="The refusal content generated by the assistant")


class MessageRefusal(BaseModel):
    """Model for refusal message content."""

    type: Literal["refusal"] = Field(
        description="The type of content part. Always refusal"
    )
    refusal: RefusalContent


MessageContent = Union[MessageText, MessageImageFile, MessageImageUrl, MessageRefusal]


AttachmentTool = Union[CodeInterpreterTool, FileSearchTool]


class MessageAttachment(BaseModel):
    """Model for file attachments in messages."""

    file_id: str = Field(description="The ID of the file to attach to the message")
    tools: Optional[List[AttachmentTool]] = Field(
        default=None, description="The tools to add this file to"
    )


class CreateMessageRequest(BaseModel):
    """Model for creating a new message."""

    role: Literal["user", "assistant"] = Field(
        description="The role of the entity creating the message"
    )
    content: Union[str, List[MessageContent]] = Field(
        description="The content of the message. Can be a string for simple text "
        "or an array of content parts for mixed content"
    )
    attachments: Optional[List[MessageAttachment]] = Field(
        default=None,
        description="A list of files attached to the message, "
        "and the tools they should be added to",
    )
    metadata: Optional[Metadata] = Field(
        default=None,
        description="Set of key-value pairs that can be attached to the message",
    )


class ModifyMessageRequest(BaseModel):
    """Model for modifying an existing message."""

    metadata: Optional[Metadata] = Field(
        default=None,
        description="Set of key-value pairs that can be attached to the message",
    )


class MessageIncompleteDetails(BaseModel):
    """Model for incomplete message details."""

    reason: str = Field(description="The reason the message is incomplete")


class MessageObject(BaseModel):
    """Model representing a message in API responses."""

    id: str = Field(description="The identifier of the message")
    object: Literal["thread.message"] = Field(
        description="The object type, which is always thread.message"
    )
    created_at: int = Field(
        description="The Unix timestamp (in seconds) for when the message was created"
    )
    thread_id: str = Field(description="The ID of the thread this message belongs to")
    role: Literal["user", "assistant"] = Field(
        description="The role of the entity that created the message"
    )
    content: List[MessageContent] = Field(
        description="The content of the message in array of text and/or images"
    )
    assistant_id: Optional[str] = Field(
        default=None,
        description="If applicable, the ID of the assistant that authored this message",
    )
    run_id: Optional[str] = Field(
        default=None,
        description="If applicable, the ID of the run associated with the message",
    )
    completed_at: Optional[int] = Field(
        default=None,
        description="The Unix timestamp (in seconds) for when the message "
        "was completed",
    )
    incomplete_at: Optional[int] = Field(
        default=None,
        description="The Unix timestamp (in seconds) for when the message "
        "was marked as incomplete",
    )
    incomplete_details: Optional[MessageIncompleteDetails] = Field(
        default=None,
        description="On an incomplete message, details about why the message "
        "is incomplete",
    )
    status: Literal["in_progress", "incomplete", "completed"] = Field(
        description="The status of the message"
    )
    attachments: List[MessageAttachment] = Field(
        default_factory=list,
        description="Files attached to the message",
    )
    metadata: Optional[Metadata] = Field(
        default=None,
        description="Set of key-value pairs attached to the message",
    )


class MessageListResponse(BaseModel):
    """Model for message list responses."""

    object: Literal["list"] = Field(description="The object type, which is always list")
    data: List[MessageObject] = Field(description="List of message objects")
    first_id: str = Field(description="The ID of the first message in the list")
    last_id: str = Field(description="The ID of the last message in the list")
    has_more: bool = Field(description="Whether there are more messages to fetch")


class DeleteMessageResponse(BaseModel):
    """Model for message deletion response."""

    id: str = Field(description="The ID of the deleted message")
    object: Literal["thread.message.deleted"] = Field(
        description="The object type, which is always thread.message.deleted"
    )
    deleted: bool = Field(description="Whether the message was deleted")
